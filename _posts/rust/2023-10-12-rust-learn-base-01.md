---
layout: post
title: Rust 基础入门 - 01
categories: [Rust]
description: Rust 基础入门 - 01
keywords: Rust 基础入门 - 01
---

这是 bran 学习 Rust 的笔记 & 心得系列，目前是 Rust 基础入门 - 01（变量、基本类型），刚开始学哦～ 加油！！！

## 变量绑定与解构

- 啊哈，变量和常量，let and const，jser 有没有很熟悉～
- println，梦回 c
- 编译器太太太强了，错误提示，很清晰，个人粗略感受，就像是 ts 中的类型提示一样，但不仅限于类型！
- rust 变量屏蔽 - js 变量作用域，看起来像，但本质不太一样
- 如果 jser 也用 typescript，那么，学习 rust 时，可以减少不少类型相关的基础
- 因为我比较熟悉 js，因此在学习 rust 的时候，总是会对比两者

## 基本类型

- rust 和 js 一样，数据类型有基本类型和（rust：单元类型）（js：引用类型）

###   数值类型

- 对于数值类型，js 相比 rust，就太灵活了，rust 在声明数值的时候，默认是 i32，既然数值有严格的定义，那么可能会出现溢出的情况！因此，jser 在学习中，就要考虑这种情况，不能任意发挥哦

  - isize、usize 是视架构而定的类型，取决于程序运行的计算机 CPU 类型：如果 CPU 是 32 位的，那这两个类型就是 32 位的，同理也可以是 64 位的；主要应用场景是用作集合的索引

- 相比 js，多了**浮点类型**，rust 有两种类型：`f32`和`f64`，默认是 f64，浮点数根据`IEEE-754`标准实现的，f32 是单精度，f64 是双精度。现代 CPU 性能足够强大，f64 的速度几乎和 f32 相同，因此默认是 f64，因为精度更高

- 在浮点数上，都会出现精度丢失问题，0.1 + 0.2 !== 0.3

- 字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。

- Rust 的数值类型和运算，看似与其他语言较为相似，但是实际上，除了语法上的不同之处，还有存在一些差异点

  - Rust 拥有相当多的数值类型，因此需要熟悉这些类型所**占用的字节数**，这样就知道**该类型允许的大小范围**，以及选择的类型是否能表达负数
  - **类型转换必须是显式的**，Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 的整数
  - Rust 数值可以使用方法，例如可以用以下方法来将 `13.14`取整：`13.14_f32.round()`，这里使用了类型后缀，因为编译器需要知道 13.14 的具体类型

> Rust 圣经作者：字符、布尔、单元类型，这三个类型所处的地位比较尴尬，你说它们重要吧，确实出现的身影不是很多，说它们不重要吧，有时候也是不可或缺，而且这三个类型都有一个共同点：简单

### 字符类型（char）

- 所有 `Unicode`值都可以作为 Rust 的字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型
- 由于`Unicode`都是 4 个字节编码，因此字符类型也是占用 4 个字节
- 和 js 不同，Rust 的字符只能用 `''`（单引号）来表示，`""`（双引号）是字符串！

### 布尔（bool）

- 布尔值占用内存的**大小为 `1`个字节**
- 使用布尔类型的场景主要用于流程控制

### 单元类型

- 单元类型就是`()`，唯一的值也是`()`。
- main 函数返回的就是单元类型`()`
- 没有返回值的函数，在 Rust 中是有单独定义的：`发散函数（diverge function)`，顾名思义，无法收敛的函数
- 常见的 `println!()`的返回值也是`()`
- jser 可以理解为 void；hh
- 和 Go 语言的 *struct{}*类似，可以作用一个值来占位，但是完全不占用任何内存

## 语句和表达式

- 可以求值的即为**表达式**
- 函数体内，前面的是**语句**（statement），最后一行是**表达式**（expression），需要能明确的区分这两个概念。（作者：对于很多其他语言来说，这两个往往无需区分。me：确实，js 不用，我有 return）
- Rust 的函数体，最后由一个表达式来返回值（多种情况下的返回呢？带着疑惑继续看
    - 十几分钟后记：也可以使用`return`提前返回
- **表达式不能用`;`结尾，否则会被认为是语句！**
- 表达式如果不返回任何值，会隐式地返回一个`()`(单元类型)

## 函数

```rust
fn add(i: i32, j: i32) -> i32 {
    i + j
}
```

- 该函数如此简单，但是又是如此的五脏俱全。声明函数的关键字`fn`（不用写 function 了 0.0），函数名、参数、参数类型、返回类型，

![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20231016105651.png)

### 函数要点

- 函数名和变量名使用下划线格式（蛇形命名法），例如：`fn add_two() -> {}`
- 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可（类似 js 的函数第一公民，函数声明提升）
- 每个函数参数都需要标注类型（如果默认值，是不是就不用标注了？带着疑惑继续看）

### 函数参数

- Rust 是强类型语言，因此每一个参数都要标识它的具体类型

### 函数返回

- 可以用 return 提前返回

- 返回值是最后一条表达式的值

- 函数也是表达式

- 不要有分号

- 特殊的返回类型

    - 无返回值

        - `()`是一个零长度的元组。

        - 函数没有返回值，那么返回一个`()`

        - 通过`;`结尾的表达式返回一个`()`

        - 示例

            ```rust
            fn cler(text: &mut String) -> () {
                *text = String::from("");
            }
            ```

            显式的返回了`()`

            ```rust
            use std::fmt::Debug;
            
            fn report<T: Debug>(item: T) {
              println!("{:?}", item);
            
            }
            ```

            report 隐式的返回一个 `()`

    - 永不返回的发散函数 `!`

        - ```rust
            fn dead_end() -> ! {
              panic!("你已经到了穷途末路，崩溃吧！");
            }
            ```

        - 当用 `!` 作函数返回类型的时候，表示该函数永不返回( diverge function )

        - 这种语法往往用做会导致程序崩溃的函数
